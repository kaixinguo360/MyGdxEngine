package com.my.utils.bool;

import com.badlogic.gdx.graphics.Mesh;
import com.badlogic.gdx.graphics.VertexAttributes;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;
import com.my.utils.VertexMixer;

import java.util.ArrayList;

/**
 * Class used to apply boolean operations on Mesh.
 *
 * <br><br>Two 'Solid' objects are submitted to this class constructor. There is a methods for
 * each boolean operation. Each of these return a 'Solid' resulting from the application
 * of its operation into the submitted solids.
 *
 * <br><br>See: D. H. Laidlaw, W. B. Trumbore, and J. F. Hughes.
 * "Constructive Solid Geometry for Polyhedral Objects"
 * SIGGRAPH Proceedings, 1986, p.161.
 *
 * @author Danilo Balby Silva Castanheira (danbalby@yahoo.com)
 */
@Deprecated
public class MeshBooleanOperation implements Cloneable
{
    /** solid where boolean operations will be applied */
    private Object3D object1, object2;

    /** 传入的两个Mesh */
    private Mesh mesh1, mesh2;

    /** 初始化attrUtils **/
    VertexMixer vertexMixer = new VertexMixer();

    //--------------------------------CONSTRUCTORS----------------------------------//

    /**
     * Constructs a MeshBooleanOperation object to apply boolean operation in two solids.
     * Makes preliminary calculations
     *
     * @param mesh1 first mesh where boolean operations will be applied
     * @param transform1 transform of the first mesh
     * @param mesh2 second mesh where boolean operations will be applied
     * @param transform2 transform of the second mesh
     */
    public MeshBooleanOperation(Mesh mesh1, Matrix4 transform1, Mesh mesh2, Matrix4 transform2)
    {
//        assert (mesh1.getVertexAttributes().equals(mesh1.getVertexAttributes())) : "两个物体顶点数据不同!";

        //保存传入的两个Mesh
        this.mesh1 = mesh1;
        this.mesh2 = mesh2;

        //设置attrUtils
        vertexMixer.addAttributes(mesh1.getVertexAttributes());
        vertexMixer.addAttributes(mesh2.getVertexAttributes());

        //representation to apply boolean operations
        object1 = new Object3D(mesh1, transform1);
        object2 = new Object3D(mesh2, transform2);

        //split the faces so that none of them intercepts each other
        object1.splitFaces(object2);
        object2.splitFaces(object1);

        //classify faces as being inside or outside the other solid
        object1.classifyFaces(object2);
        object2.classifyFaces(object1);
    }

    //----------------------------------OVERRIDES-----------------------------------//

    /**
     * Clones the MeshBooleanOperation object
     *
     * @return cloned MeshBooleanOperation object
     */
    public Object clone()
    {
        try
        {
            MeshBooleanOperation clone = (MeshBooleanOperation)super.clone();
            clone.object1 = (Object3D)object1.clone();
            clone.object2 = (Object3D)object2.clone();
            return clone;
        }
        catch(CloneNotSupportedException e)
        {
            return null;
        }
    }

    //-------------------------------BOOLEAN_OPERATIONS-----------------------------//

    /**
     * Gets the solid generated by the union of the two solids submitted to the constructor
     *
     * @return solid generated by the union of the two solids submitted to the constructor
     */
    public Mesh getUnion()
    {
        return composeMesh(Face.OUTSIDE, Face.SAME, Face.OUTSIDE);
    }

    /**
     * Gets the solid generated by the intersection of the two solids submitted to the constructor
     *
     * @return solid generated by the intersection of the two solids submitted to the constructor.
     * The generated solid may be empty depending on the solids. In this case, it can't be used on a scene
     * graph. To check this, use the Solid.isEmpty() method.
     */
    public Mesh getIntersection()
    {
        return composeMesh(Face.INSIDE, Face.SAME, Face.INSIDE);
    }

    /** Gets the solid generated by the difference of the two solids submitted to the constructor.
     * The fist solid is substracted by the second.
     *
     * @return solid generated by the difference of the two solids submitted to the constructor
     */
    public Mesh getDifference()
    {
        object2.invertInsideFaces();
        Mesh result = composeMesh(Face.OUTSIDE, Face.OPPOSITE, Face.INSIDE);
        object2.invertInsideFaces();

        return result;
    }

    //--------------------------PRIVATES--------------------------------------------//

    /**
     * Composes a Mesh based on the faces status of the two operators solids:
     * Face.INSIDE, Face.OUTSIDE, Face.SAME, Face.OPPOSITE
     *
     * @param faceStatus1 status expected for the first solid faces
     * @param faceStatus2 other status expected for the first solid faces
     * (expected a status for the faces coincident with second solid faces)
     * @param faceStatus3 status expected for the second solid faces
     */
    private Mesh composeMesh(int faceStatus1, int faceStatus2, int faceStatus3)
    {
        ArrayList<Vertex> vertices = new ArrayList<>();
        ArrayList<Integer> indices = new ArrayList<>();
        ArrayList<VertexData> datas = new ArrayList<>();

        //group the elements of the two solids whose faces fit with the desired status
        groupObjectComponents(object1, vertices, indices, datas, faceStatus1, faceStatus2);
        groupObjectComponents(object2, vertices, indices, datas, faceStatus3, faceStatus3);

        if(indices.size() == 0) {
            return null;
        }

        //returns the solid containing the grouped elements
        return buildMesh(vertices, indices, datas);
    }

    /**
     * Fills solid arrays with data about faces of an object generated whose status
     * is as required
     *
     * @param object solid object used to fill the arrays
     * @param vertices vertices array to be filled
     * @param indices indices array to be filled
     * @param datas datas array to be filled
     * @param faceStatus1 a status expected for the faces used to to fill the data arrays
     * @param faceStatus2 a status expected for the faces used to to fill the data arrays
     */
    private void groupObjectComponents(Object3D object, ArrayList vertices, ArrayList indices, ArrayList datas, int faceStatus1, int faceStatus2)
    {
        Face face;
        //for each face..
        for(int i=0;i<object.getNumFaces();i++)
        {
            face = object.getFace(i);
            //if the face status fits with the desired status...
            if(face.getStatus()==faceStatus1 || face.getStatus()==faceStatus2)
            {
                //adds the face elements into the arrays
                Vertex[] faceVerts = {face.v1, face.v2, face.v3};
                for(int j=0;j<faceVerts.length;j++)
                {
                    if(vertices.contains(faceVerts[j]))
                    {
                        indices.add(new Integer(vertices.indexOf(faceVerts[j])));
                    }
                    else
                    {
                        indices.add(new Integer(vertices.size()));
                        vertices.add(faceVerts[j]);
                        datas.add(faceVerts[j].getData());
                    }
                }
            }
        }
    }

    private Mesh buildMesh(ArrayList<Vertex> vertices, ArrayList<Integer> indexs, ArrayList<VertexData> datas) {
        assert (vertices.size() == datas.size()) : "integer与datas数组长度不相等!";
//        assert (mesh1.getVertexAttributes().equals(mesh1.getVertexAttributes())) : "两个物体顶点数据不同!";

        int vertexNum = datas.size();
        vertexMixer.begin(vertexNum);
        Vector3 tmpV = new Vector3();
        for(int i=0; i<vertexNum; i++) {
            Vertex vertice = vertices.get(i);
            VertexData data = datas.get(i);
            int id = 0;
            if(data.getMesh() == mesh1) {
                id = 0;
            } else if(data.getMesh() == mesh2) {
                id = 1;
            } else {
                assert true : "Unknown Mesh!!!";
            }
            vertexMixer.addVertex(id, data.getData(), vertice.toVector3(tmpV));
        }
        float[] vs = vertexMixer.build();

        short[] is = new short[indexs.size()];
        for(int i=0; i<indexs.size(); i++) {
            if(indexs.get(i) > Short.MAX_VALUE || indexs.get(i) < Short.MIN_VALUE) {
                throw new RuntimeException("Index Is Too Bigger!");
            }
            is[i] = (short) (int) indexs.get(i);
        }

        VertexAttributes as = vertexMixer.getTargetAttr();

        //Build Mesh
        Mesh mesh = new Mesh(false, vs.length, is.length, as);
        mesh.setVertices(vs);
        mesh.setIndices(is);
        return mesh;
    }
}















